#######################################################################################################################
##################  This code models the trajectories based on parameters generated by Monolix ######################## 
#######################################################################################################################
```{r}
library(deSolve)
library(ggplot2)
library(dplyr)
library(purrr)
library(MASS)
```

############ For T cell responses, we use an inactivation model to simulate the trajectories ###############
```{r}
pop <- read.csv("populationParameters.txt",  row.names = 1) # read IFNg paramters or IL2 parameters
```


####### define immunity conferring events for population fit ##########
```{r}
immu_detail <- data.frame(immu_group = c( "uninfected", 
                                  "infected", 
                                  "boosted", 
                                  "infected_boosted"
                                  ),
                         immu = c(1,2,3,4)
                 )
immu_detail_1 <- immu_detail %>% mutate(
  inf = c(NA,150,NA,150),
  boost = c(NA,NA,303,303)
)
```

##################################################################################
######### ODEl inactivation model with infection/boost/reinfection ###############
##################################################################################

```{r}
ode_IFNg_pop <- function(pars, immu) {
  alpha_pop <- as.numeric(pars[1])
  gamma_pop <- as.numeric(pars[2])
  alpha1_pop <- as.numeric(pars[3])
  gamma1_pop <- as.numeric(pars[4])
  beta_pop <- as.numeric(pars[5])
  beta1_pop <- as.numeric(pars[6])
  A0 <- as.numeric(pars[7])
  t_inf <- as.numeric(pars[8])
  t_boost <- as.numeric(pars[9])
  t_inf2 <- as.numeric(pars[10])

  times <- seq(Tmin, Tmax, step_size) #Corrected times creation

  derivs <- function(times, y, pars, immu) {
    with(as.list(c(pars, y, immu)), {
      if (immu == 1) {
        dA <- alpha_pop * exp(-gamma_pop * times) - beta_pop * A
      } else if (immu == 2) {
        if(t_inf2 <= 0) {
          if (times <= t_inf) {
            dA <- alpha_pop * exp(-gamma_pop * times) - beta_pop * A
            } else if (times > t_inf) {
              dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf)) - beta1_pop * A
              }
        } else if (t_inf2 > 0) {
          if (times <= t_inf & times <= t_inf2) {
            dA <- alpha_pop * exp(-gamma_pop * times) - beta_pop * A
            } else if (times > t_inf & times <= t_inf2) {
              dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf)) - beta1_pop * A
              } else if (times > t_inf & times > t_inf2) {
                dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf2)) - beta1_pop * A
              }
          }
      } else if (immu == 3) {
        if (times <= t_boost) {
          dA <- alpha_pop * exp(-gamma_pop * times) - beta_pop * A
        } else {
          dA <- alpha1_pop * exp(-gamma1_pop * (times - t_boost)) - beta1_pop * A
        }
      } else if (immu == 4) {
        if (t_inf2 <= 0) {
          if (t_inf < t_boost) {
            if (times <= t_inf & times <= t_boost) {
              dA <- alpha_pop * exp(-gamma_pop * times) - beta_pop * A
            } else if (times > t_inf & times <= t_boost) {
              dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf)) - beta1_pop * A
            } else if (times > t_inf & times > t_boost) {
              dA <- alpha1_pop * exp(-gamma1_pop * (times - t_boost)) - beta1_pop * A
            }
          } else if (t_inf > t_boost) {
            if (times <= t_inf & times <= t_boost) {
              dA <- alpha_pop * exp(-gamma_pop * times) - beta_pop * A
            } else if (times <= t_inf & times > t_boost) {
              dA <- alpha1_pop * exp(-gamma1_pop * (times - t_boost)) - beta1_pop * A
            } else if (times > t_inf & times > t_boost) {
              dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf)) - beta1_pop * A
            }
          }
        } else if (t_inf2 > 0) {
          if (times <= t_inf & times <= t_boost & times <= t_inf2) {
            dA <- alpha_pop * exp(-gamma_pop * times) - beta_pop * A
            } else if (t_boost < t_inf2) {
              if (times > t_inf & times <= t_boost & times <= t_inf2) {
                dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf)) - beta1_pop * A
                } else if (times > t_inf & times > t_boost & times <= t_inf2) {
                  dA <- alpha1_pop * exp(-gamma1_pop * (times - t_boost)) - beta1_pop * A
                  } else if (times > t_inf & times > t_boost & times > t_inf2) {
                    dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf2)) - beta1_pop * A
                    }
              } else if (t_boost > t_inf2) {
                if (times > t_inf & times <= t_boost & times <= t_inf2) {
                  dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf)) - beta1_pop * A
                  } else if (times > t_inf & times <= t_boost & times > t_inf2) {
                    dA <- alpha1_pop * exp(-gamma1_pop * (times - t_inf2)) - beta1_pop * A
                    } else if (times > t_inf & times > t_boost & times > t_inf2) {
                      dA <- alpha1_pop * exp(-gamma1_pop * (times - t_boost)) - beta1_pop * A
                    }
              }
        }
        }
      return(list(c(dA = dA)))
      }
    )
    }
  y <- c(A = A0)

  out <- ode(y = y, parms = pars, times = times, func = derivs, immu = immu)
  as.data.frame(out)
}
```

################# sampling function to generate virtual cohort #####################

```{r}
sample_IFNg <- function(pop, num){
  
  inds_mean <- which(rownames(pop) %in% c("alpha_pop","gamma_pop","alpha1_pop","gamma1_pop","beta_pop","beta1_pop","A0_pop"))
  inds_sd <- which(rownames(pop) %in% c("omega_alpha","omega_gamma","omega_alpha1","omega_gamma1","omega_beta","omega_beta1","omega_A0"))

  pars <- matrix(0, num+1, length(inds_mean))
  
  for (i in 1:length(inds_mean)) {
    mean_par <- pop$value[inds_mean[i]]
    sd_par <- pop$value[inds_sd[i]]
    
    
    if (i==1) {
      log_alpha = log(mean_par)
      pars[1:num, i] <- exp(rnorm(num, mean = log_alpha, sd=sd_par))
      pars[num+1, i] <- exp(log_alpha)
    } 
    
    else if (i==2 ) {
      
      log_gamma = log(mean_par)
      pars[1:num, i] <- exp(rnorm(num, mean = log_gamma, sd=sd_par))
      pars[num+1, i] <- exp(log_gamma)
    } 
    
    else if (i==3 ) {
       log_alpha1 = log(mean_par)
      pars[1:num, i] <- exp(rnorm(num, mean = log_alpha1, sd=sd_par))
      pars[num+1, i] <- exp(log_alpha1)
    } 
    
    else if (i==4 ) {
      log_gamma1 = log(mean_par)
      pars[1:num, i] <- exp(rnorm(num, mean = log_gamma1, sd=sd_par))
      pars[num+1, i] <- exp(log_gamma1)
    } 
    else if (i==5) {
      
      log_beta = log(mean_par)
      pars[1:num, i] <- exp(rnorm(num, mean = log_beta, sd=sd_par))
      pars[num+1, i] <- exp(log_beta)
    } 
    
    else if (i==6 ) {
       log_beta1 = log(mean_par)
      pars[1:num, i] <- exp(rnorm(num, mean = log_beta1, sd=sd_par))
      pars[num+1, i] <- exp(log_beta1)
    } 
      
    
    else if (i==7 ) {
     
    log_A0 = log(mean_par)
      pars[1:num, i] <- exp(rnorm(num, mean = log_A0, sd=sd_par))
      pars[num+1, i] <- exp(log_A0)
    }
  }
  pars <- cbind(pars, rep(t_inf_pop, num+1))
  pars <- cbind(pars, rep(t_boost_pop, num+1))
  pars <- cbind(pars, rep(0, num+1))
  
  
  return(pars)
}
```
```{r}
run_ODE_control_IFNg <- function(pars, immu){
  total_IFNg <- matrix(NA,nrow=length(seq(Tmin,Tmax,step_size)),ncol=n)
  for(i in 1:n){
    out <- ode_IFNg_pop(as.numeric(pars[i,]), immu = immu[i])
  total_IFNg[,i] <- out$A
  }
  return(total_IFNg)
}
```
####################################################
######## generate population fitting ###############
####################################################

```{r}
n = 1000 #1000 simulations
Tmin <- 0
Tmax <- 450
step_size <- 1
times<-c(seq(Tmin,Tmax,step_size))

Fit <- list()
pb <- txtProgressBar(min = 0, max = 4, style =3)

for (g in 1:4){
  immu_i <- immu_detail$immu[g]
  rep_immu <- rep(immu_i, n+1)
  if (g == 1) {
    t_inf_pop = 0
    t_boost_pop = 0
  } else if (g == 2) {
    t_inf_pop = 150
    t_boost_pop = 0
  } else if (g == 3) {
    t_inf_pop = 0
    t_boost_pop = 303
  } else if (g == 4) {
    t_inf_pop = 150
    t_boost_pop = 303
  }

  par <- c(alpha = pop["alpha_pop", "value"],
           gamma = pop["gamma_pop", "value"],
           alpha1 = pop["alpha1_pop", "value"],
           gamma1 = pop["gamma1_pop", "value"],
           beta = pop["beta_pop", "value"],
           beta1 = pop["beta1_pop", "value"],
           B0 = pop["A0_pop", "value"],
           t_inf = t_inf_pop,
           t_boost = t_boost_pop,
           t_inf2 = 0)
  
  best_fit <- ode_IFNg_pop(par, immu = immu_i)
  
  pars <- sample_IFNg(pop, n)
  total_IFNg <- run_ODE_control_IFNg(pars, immu = rep_immu)
  
  Min90  <- apply(total_IFNg,1,function(x){quantile(x,0.05,na.rm=T)})
  Max90  <- apply(total_IFNg,1,function(x){quantile(x,0.95,na.rm=T)})
  Min50  <- apply(total_IFNg,1,function(x){quantile(x,0.25,na.rm=T)})
  Max50  <- apply(total_IFNg,1,function(x){quantile(x,0.75,na.rm=T)})
  Mean50  <- apply(total_IFNg,1,function(x){quantile(x,0.5,na.rm=T)})
  Min30  <- apply(total_IFNg,1,function(x){quantile(x,0.30,na.rm=T)})
  Max30  <- apply(total_IFNg,1,function(x){quantile(x,0.70,na.rm=T)})

  Fit[[g]] <- cbind(best_fit,Min90,Max90,Min50,Max50,Mean50,Min30,Max30, rep(immu_i, length(times)))
  Fit[[g]] <- data.frame(Fit[[g]])
  colnames(Fit[[g]]) <- c("time","best_fit","Min90","Max90","Min50","Max50","Mean50","Min30","Max30", "Immu_group")
  setTxtProgressBar(pb, g)
}
close(pb)
combine_pop <- map_df(Fit, ~as.data.frame(.x))
```

```{r}
combine_pop <- merge(immu_detail, combine_pop, by.x = "immu", by.y = "Immu_group")
combine_pop
```
```{r}
combine_pop <- combine_pop %>%
  mutate(t_inf = case_when(
    immu_group == "uninfected" ~ NA,
    immu_group == "infected" ~ 150,
    immu_group == "boosted" ~ NA,
    immu_group == "infected_boosted" ~ 150
  )) %>%
  mutate(t_boost = case_when(
    immu_group == "uninfected" ~ NA,
    immu_group == "infected" ~ NA,
    immu_group == "boosted" ~ 303,
    immu_group == "infected_boosted" ~ 303
  ))
combine_pop
```
#############################################
############## Figure-3 D&E #################
#############################################
```{r}
plot_pop_log <- ggplot(combine_pop, aes(x = time)) +
 
  geom_ribbon(aes(ymin = log10(Min90), ymax = log10(Max90), fill = immu_group), alpha = 0.15) +
  geom_ribbon(aes(ymin = log10(Min50), ymax = log10(Max50), fill = immu_group), alpha = 0.3) +

  geom_line(aes(y = log10(Mean50), color = immu_group), size = 1.5, alpha = 0.8) +
  
  
  geom_vline(aes(xintercept = t_inf), color = "red",linetype = "dotted", size = 1, alpha = 0.5) +
  geom_vline(aes(xintercept = t_boost), color = "blue",linetype = "dotted", size = 1, alpha = 0.5) +
 
  facet_wrap(~ immu_group) +# , scales = "free_y")+
  theme(axis.text = element_text(colour = "black"),
        axis.ticks = element_line(colour = "black"),
        axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.position='none',
        axis.title.y = element_text(size=11,family="sans"),
        axis.title.x = element_text(size=11,family="sans"),
  theme_minimal() 
  ) +
  labs(
    #title = "Individual Fit of IFNg with Shaded Uncertainty",
    x = "Time (days)",
    y = "log 10 IFNg (pg/ml)"
  )
plot_pop_log
```
#########################################
```{r}
plot_pop_log <- ggplot(combine_pop, aes(x = time)) +
 
  geom_ribbon(aes(ymin = log10(Min90), ymax = log10(Max90), fill = immu_group), alpha = 0.15) +
  geom_ribbon(aes(ymin = log10(Min50), ymax = log10(Max50), fill = immu_group), alpha = 0.3) +

  geom_line(aes(y = log10(Mean50), color = immu_group), size = 1.5, alpha = 0.8) +
  
  
  geom_vline(aes(xintercept = t_inf), color = "red",linetype = "dotted", size = 1, alpha = 0.5) +
  geom_vline(aes(xintercept = t_boost), color = "blue",linetype = "dotted", size = 1, alpha = 0.5) +
 
  facet_wrap(~ immu_group) +# , scales = "free_y")+
  theme(axis.text = element_text(colour = "black"),
        axis.ticks = element_line(colour = "black"),
        axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.position='none',
        axis.title.y = element_text(size=11,family="sans"),
        axis.title.x = element_text(size=11,family="sans"),
  theme_minimal() 
  ) +
  labs(
    #title = "Individual Fit of IFNg with Shaded Uncertainty",
    x = "Time (days)",
    y = "log 10 IFNg (pg/ml)"
  )
plot_pop_log
```


###########################################################################################################
################################## Individual Fitting #####################################################
###########################################################################################################

############ Process original data to obtain inf/boost information ################
```{r}
Original <- read.csv("C:/Users/YIYU.LIAO/OneDrive - Nanyang Technological University/Desktop/immu correlate/MONOLIX/IFNg/df_full_IFNg_reinf2.csv")
Original <- Original[, -c(10, 11)]
Original <- Original %>% mutate(
  imm = 
    case_when(inf == 0 & boost == 0 ~ 1,
              inf == 1 & boost == 0 ~ 2,
              inf == 0 & boost == 1 ~ 3,
              inf == 1 & boost == 1 ~ 4)
)

ori_fil <- Original[, c(1, 5, 7, 9, 10)]
ori_fil <- ori_fil %>% 
  group_by(ID) %>%
  slice_head( n = 1) %>%
  rename(id = ID)

immu_detail_individuals <- Original %>%
  group_by(ID) %>%
  slice_head(n=1) %>%
  dplyr::select(ID,inf,t_inf,inf2,t_inf2,boost, t_boost) %>%
  mutate(immu = case_when(
    inf == 0 & boost == 0 ~ 1,
    inf == 1 & boost == 0 ~ 2,
    inf == 0 & boost == 1 ~ 3,
    inf == 1 & boost == 1 ~ 4
  )) %>% full_join(immu_detail, by= "immu")
immu_detail_individuals

Original_immu <- merge(Original,immu_detail_individuals[, c(1,9)], by = "ID") %>%
  rename(Code = ID)

Original_immu
```
############ Read monolix parameter ###############
```{r}
Est_file <- read.csv("estimatedIndividualParameters.txt", sep = ",", comment.char = "", header = T) # Modify the path to Monolix individual parameters file
Simulated_file <- read.csv("simulatedIndividualParameters.txt", sep = ",", comment.char = "", header = T) # Modify the path to Monolix individual parameters file
Est_file
Simulated_file
```
######### merge parameters with inf/boost information ##########
```{r}
Est <- Est_file %>% full_join(ori_fil, by = "id")
Est
Simulated <- Simulated_file %>% full_join(ori_fil, by = "id")
Simulated
```
########### Individual Fitting function ############
```{r}
Tmin <- 0
Tmax <- 500 
step_size <- 1
times<-c(seq(Tmin,Tmax,step_size))
n <- 100

ind_fit_plt<-function(Est,Simulated,immunity){
  
  Fit <- list()
  for(i in 1:nrow(Est)){
    parslist <- c(alpha_pop=Est$alpha_mode[i],
              gamma_pop=Est$gamma_mode[i],
              alpha1_pop=Est$alpha1_mode[i],
              gamma1_pop=Est$gamma1_mode[i],
              beta_pop=Est$beta_mode[i],
              beta1_pop=Est$beta1_mode[i],
              A0=Est$A0_mode[i],
              t_inf=Est$t_inf[i],
              t_boost=Est$t_boost[i],
              t_inf2=Est$t_inf2[i])
    
    target_id <- Est$id[i]
    immu <- immunity %>% filter(ID == target_id)
  
 
    fitted <- ode_IFNg_pop(parslist, immu)
    d1 <- data.frame(Days=(times),y=(fitted$A))
    Code <- Est$id[i]
    
    max_fit <- max(d1$y)

    
    S <- max(Simulated$rep) ###100 repeats
    P <- matrix(NA,nrow=length(times),ncol=S)
    
    
    for(j in 1:S){   # for each individuals, we generated 50 simulated parameters using monolix, we use the simulated pars to calculate CI
      index <- j + S * (i - 1)
      
      pars <- c(alpha_pop=Simulated$alpha[index],
                gamma_pop=Simulated$gamma[index],
                alpha1_pop=Simulated$alpha1[index],
                gamma1_pop=Simulated$gamma1[index],
                beta_pop=Simulated$beta[index],
                beta1_pop=Simulated$beta1[index],
                A0=Simulated$A0[index],
                t_inf=Simulated$t_inf[index],
                t_boost=Simulated$t_boost[index],
                t_inf2=Simulated$t_inf2[index]
               )
      
      out  <- ode_IFNg_pop(pars, immu)
      P[,j] <- out$A
    }
    
    Min  <- apply(P,1,function(x){quantile(x,0.025)})
    Max  <- apply(P,1,function(x){quantile(x,0.975)})
    
    fit <- cbind(d1,Min,Max,Code)
    
    Fit[[i]] <- data.frame(fit)
  }
  
  ind_fit_unlist <- map_df(Fit, ~as.data.frame(.x))
  ind_fit <- merge(ind_fit_unlist, immunity, by.x = "Code", by.y = "ID", all.x = TRUE)
  ind_fit$Code <- as.factor(ind_fit$Code)
  ind_fit <- ind_fit[order(ind_fit$Code, ind_fit$Days), ]
  return(ind_fit)
}
```

```{r}
individual_fit <- ind_fit_plt(Est, Simulated, immunity = immu_detail_individuals)
```

```{r}
# Create 2 subset for individual infection/booster timing 
ind_inf <- Original %>%
  rename(Code = ID) %>%
  filter(inf != 0) %>%
  dplyr::select(Code,t_inf) %>%
  group_by(Code) %>%
  slice_head(n=1)
ind_inf

ind_boost <- Original %>%
  rename(Code = ID) %>%
  filter(boost != 0) %>%
  dplyr::select(Code,t_boost) %>%
  group_by(Code) %>%
  slice_head(n=1)
ind_boost

ind_inf2 <- Original %>%
  rename(Code = ID) %>%
  filter(inf2 != 0) %>%
  dplyr::select(Code,t_inf2) %>%
  group_by(Code) %>%
  slice_head(n=1)
ind_inf2
```

#####################################
########## S-Fig-5 & 6 ##############
#####################################
```{r}
plot_indfit_log <- ggplot(individual_fit, aes(x = Days)) +
 
  geom_ribbon(aes(ymin = log10(Min), ymax = log10(Max), fill = immu_group), alpha = 0.3) +

  geom_line(aes(y = log10(y), color = immu_group), size = 1, alpha = 0.8) +
  
  
  geom_vline(data =ind_inf,  aes(xintercept = t_inf),color = "red",linetype = "dotted", size = 1, alpha = 0.5) +
  geom_vline(data =ind_boost,  aes(xintercept = t_boost),color = "blue",linetype = "dotted", size = 1, alpha = 0.5) +
  geom_vline(data=ind_inf2, aes(xintercept = t_inf2), color = "red", linetype = "dotted", size = 1, alpha = 0.5) +
  #add inf time, boost time
  geom_point(data = Original_immu, aes(x = Day, y = log10(IFNg), color = immu_group),
             shape = 16, size = 2, alpha = 2) +
 
  facet_wrap(~ Code )+
 theme(axis.text = element_text(colour = "black"),
        axis.ticks = element_line(colour = "black"),
        axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.position='bottom',
        axis.title.y = element_text(size=11,family="sans"),
        axis.title.x = element_text(size=11,family="sans"),
  theme_minimal() 
  )   +
  
  labs(
    #title = "Individual Fit of IFNg with Shaded Uncertainty",
    x = "Time (days)",
    y = "log IFNg (pg/ml)",
    fill = "Immune Group",
    color = "Immune Group"
  )
plot_indfit_log
```
